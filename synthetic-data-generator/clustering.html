<html>
  <head>
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css"/>
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>

<style>

*{
    margin: 0%;
    padding: 0%;
    box-sizing: border-box;
    font-family: arial,sans-serif;
}

.container{
    display: flex;
    align-items: flex-start;
    justify-content: center;
}

.title{
    width: 100%;
    font-size: 32px;
    font-weight: bolder;
    text-align: center;
    background-color: aliceblue;
}

.left-container, .right-container{
    width: 25vw;
    min-height: 99vh;
    height: 100%;
    padding: 10px;
    background-color: aliceblue;
}

form, .data-description{
    width: 100%;
    padding: 10px;
    background-color: rgb(240, 240, 240);
    border-radius: 6px;
    box-shadow: 0px 0px 8px gray;
    margin-bottom: 20px;
}

#data_description, #cluster_description{
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

h3{
  width: 100%;
  text-align: center;
  padding-bottom: 6px;
}

table{
    width: 100%;
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
  padding: 4px;
}

label{
    width: 60%;
    display: inline-block;
    font-size: 18px;
    border-bottom: 1px solid lightgray;
}

input, select{
    background-color: white;
    border: 1px solid;
    border-radius: 4px;
    font-size: 18px;
    height: 32px;
    width: 38%;
    margin-bottom: 10px;
}

button {
    text-decoration:none;
    width: 100%;
    background-color: rgb(200, 200, 200);
    border: 1px solid rgb(200, 200, 200);
    border-radius: 4px;
    color: black;
    font-family: arial,sans-serif;
    font-size: 18px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center; 
    cursor: pointer;
    margin-top: 20px;
}

#restriced{
    cursor: not-allowed;
}

button:hover{
    border: 1px solid black;
}

.graph_area{
    width: 50vw;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
}

#generated_data_graph, #cluster_data_graph{
    width: 100%;
    display: contents;
}

</style>
  </head>
  <body>
    <div class="title">Clustering with Synthetic Data</div>
    <div class="container">
      <div class="left-container">
        <form>
            <h3>Data Generation Options</h3>
            <label>Choose Distribution Type:</label>
            <select id="distribution_type">
                <option value="uniform">Uniform</option>
                <option value="normal">Normal</option>
                <option value="gaussian">Gaussian</option>
                <option value="t">T</option>
            </select>
            <label>Number of Rows:</label>
            <input type="number" id="num_datapoints" placeholder="Number of rows" value="100" min="3" step="1"/>
            <br>
            <label>Number of Dimensions: (2 or 3)</label>
            <input type="number" id="no_of_dimensions" placeholder="Number of dimensions" value="2" min="2" max="3" step="1"/>
            <br>
            <label>Number of Clusters: (2 or 3)</label>
            <input type="number" id="no_of_cluster" placeholder="Number of clusters" value="2" min="2" max="3" step="1"/>
            <br>
            <label>Higher Limit of First Cluster:</label>
            <input type="number" id="l" placeholder="Linear combination" value="1" min="1" max="10" step="1"/>
            <br>
            <label>Overlap Percentage:</label>
            <input type="number" id="overlap_percentage" placeholder="Overlap Percentage" value="0" min="0" max="1" step=".01"/>
            <br>
            <label>Imbalance Percentage:</label>
            <input style="width: 18.5%;" type="number" id="imbalance_1" placeholder="C1" min="0" max=".5" step=".01"/>
            <input style="width: 18.5%;" type="number" id="imbalance_2" placeholder="C2" min="0" max=".5" step=".01"/>
            <br>

            <button onclick="get_value(); add_py_click();" py-click="generate_overlapping_clusters(js.no_of_cluster, js.no_of_dimensions, js.num_datapoints, js.overlap_percentage, js.l, [js.imbalance_1, js.imbalance_2], js.distribution_type)" type="button">
                Generate Data
            </button>
        </form>
        
        <div class="data-description">
          <h3>Generated Data Description</h3>
          <div id="data_description">please generate data!</div>
        </div>
    </div>
    
      <div class="graph_area">
          <div id="generated_data_graph"></div>
          <div id="cluster_data_graph"></div>
      </div>
  
      <div class="right-container">
        <form>
            <h3>Clustering Algorithm Options</h3>
            <label>Choose Clustering Algorithm:</label>
            <select id="clustering_algorithm">
                <option value="kmeans">K-Means</option>
                <option value="hierarchical_clustering">Hierarchical</option>
                <option value="gmm"> Gaussian Mixture Model</option>
                <option value="mean_shift">Mean-Shift</option>
            </select>
            <label>Number of Clusters:</label>
            <input type="number" id="no_of_cluster_algo" placeholder="Number of clusters" value="2" min="2" step="1"/>
            <br>

            <button onclick="get_value();" type="button" id="restriced">
                Cluster Data
            </button>
            <!-- <button onclick="get_value();" py-click="clustering(js.clustering_algorithm)" type="button" id="restriced">
                Cluster Data
            </button> -->
        </form>

        <div class="data-description" style="display: flex; align-items: center; justify-content: center; flex-direction: column;">
            <h3>External Measure</h3>
            <table>
                <tr>
                    <td><b>Precision</b></td>
                    <td id="precision"></td>
                </tr>
                <tr>
                    <td><b>Recall</b></td>
                    <td id="recall"></td>
                </tr>
                <tr>
                    <td><b>F-measure</b></td>
                    <td id="f_measure"></td>
                </tr>
                <tr>
                    <td><b>Adjusted Rand Index</b></td>
                    <td id="ari"></td>
                </tr>
            </tbody>
        </table>
        
        <h3 style="padding-top: 6px;">Internal Measure</h3>
        <table>
            <tr>
                <td><b>SSE</b></td>
                <td id="sse"></td>
            </tr>
            <tr>
                <td><b>Silhouette Coefficient</b></td>
                <td id="silhouette"></td>
            </tr>
            <tr>
                <td><b>Dunn Index</b></td>
                <td id="dunn"></td>
            </tr>
              </tbody>
            </table>
        </div>

        <div class="data-description">
            <h3>Clustered Data Description</h3>
            <div id="cluster_description">please cluster data!</div>
        </div>

      </div>
    </div>
    
    <script>
        var distribution_type = document.getElementById("distribution_type").value;
        var num_datapoints = parseInt(document.getElementById("num_datapoints").value);
        var no_of_dimensions = parseInt(document.getElementById("no_of_dimensions").value);
        var no_of_cluster = parseInt(document.getElementById("no_of_cluster").value);
        var l = parseInt(document.getElementById("l").value);
        var overlap_percentage = parseFloat(document.getElementById("overlap_percentage").value);
        var imbalance_1 = parseFloat(document.getElementById("imbalance_1").value);
        var imbalance_2 = parseFloat(document.getElementById("imbalance_2").value);
        var clustering_algorithm = document.getElementById("clustering_algorithm").value;
        var no_of_cluster_algo = parseInt(document.getElementById("no_of_cluster_algo").value);
        

        var restriced = document.getElementById("restriced");

        // var data_description = document.getElementById("data_description");
        // var cluster_description = document.getElementById("cluster_description");
        
    
        function get_value() {
            distribution_type = document.getElementById("distribution_type").value;
            num_datapoints = parseInt(document.getElementById("num_datapoints").value);
            
            no_of_dimensions = parseInt(document.getElementById("no_of_dimensions").value);
            if(no_of_dimensions > 3) {no_of_dimensions = 3};

            no_of_cluster = parseInt(document.getElementById("no_of_cluster").value);
            if(no_of_cluster > 3) {no_of_cluster = 3};
            
            l = parseInt(document.getElementById("l").value);
            overlap_percentage = parseFloat(document.getElementById("overlap_percentage").value);
            if(overlap_percentage > 1) {overlap_percentage = 1};
            
            imbalance_1 = parseFloat(document.getElementById("imbalance_1").value);
            if(isNaN(imbalance_1) || imbalance_1 > .5){
                if(no_of_cluster == 2){imbalance_1 = .5}
                if(no_of_cluster == 3){imbalance_1 = .3333}
            }

            imbalance_2 = parseFloat(document.getElementById("imbalance_2").value);
            if(isNaN(imbalance_2) || imbalance_2 > .5){
                if(no_of_cluster == 2){imbalance_2 = .5}
                if(no_of_cluster == 3){imbalance_2 = .3333}
            }

            clustering_algorithm = document.getElementById("clustering_algorithm").value;
            no_of_cluster_algo = parseInt(document.getElementById("no_of_cluster_algo").value);
            
            console.log(no_of_cluster_algo)
            
            setTimeout(() => {
                //data_description.innerHTML += "<a href = \"pyscript.interpreter.globals.get('x')\" download = \"file_name.csv\"><button>Download Data</button></a>"
            }, 100);
        }

        function add_py_click() {
            restriced.style.cursor = "pointer";
            restriced.setAttribute("py-click", "clustering(js.clustering_algorithm)")
        }


    </script>

    <py-config>
      packages = ["numpy", "pandas", "matplotlib", "scikit-learn"]
    </py-config>

    <py-script>
        import js
        import numpy as np
        import pandas as pd
        import matplotlib.pyplot as plt
        import warnings
        warnings.filterwarnings("ignore")
        
        np.random.seed(42)
        
        no_of_gen_cluster = js.no_of_cluster
        num_dimensions = js.no_of_dimensions

        def generate_overlapping_clusters(num_clusters, num_dimensions, num_datapoints, overlap_percentage, L, cluster_percentage_list, distribution_type):
            num_dimensions = js.no_of_dimensions
            range_list = []

            for i in range(num_clusters*2):
                if i == 0:
                    range_list.append(np.random.uniform(0, L))
                if i > 0 and i % 2 == 0:
                    range_list.append(range_list[i-1] - L * (overlap_percentage ** (1 / num_dimensions)))
                if i % 2 != 0:
                    range_list.append(range_list[i-1] + L)
        
            if len(cluster_percentage_list) < num_clusters:
                remaining_percentage = 1 - np.sum(cluster_percentage_list)
                cluster_percentage_list.append(remaining_percentage)
        
            total_points = num_datapoints
            total_points_per_cluster = np.round(total_points * np.array(cluster_percentage_list), decimals=0)
            total_points_assigned = np.sum(total_points_per_cluster)
            total_points_per_cluster[-1] += total_points - total_points_assigned
            col_dict = {}
        
            cluster_indices_per_cluster = []  # List to store cluster index for each data point within a cluster
        
            for cluster in range(num_clusters):
                points_per_cluster = int(total_points_per_cluster[cluster])
        
                if distribution_type == "uniform":
                    cluster_data = np.random.uniform(range_list[cluster*2], range_list[cluster*2 + 1], (points_per_cluster, num_dimensions))
                elif distribution_type == "normal":
                    cluster_data = np.random.normal((range_list[cluster*2] + range_list[cluster*2 + 1]) / 2, (range_list[cluster*2 + 1] - range_list[cluster*2]) / 4, (points_per_cluster, num_dimensions))
                elif distribution_type == "gaussian":
                    cluster_data = np.random.standard_normal((points_per_cluster, num_dimensions))
                elif distribution_type == "t":
                    cluster_data = np.random.standard_t(3, (points_per_cluster, num_dimensions))
        
                cluster_indices_per_cluster.extend([f'C{cluster+1}'] * points_per_cluster)
        
                for dimension in range(num_dimensions):
                    col_name = f"Dimension {dimension+1}"
                    if col_name not in col_dict:
                        col_dict[col_name] = []
                    col_dict[col_name].extend(cluster_data[:, dimension])
        
            global df
            df = pd.DataFrame(col_dict)
            df['Cluster'] = cluster_indices_per_cluster
            
            
            # Plot the Generated Data
            Element('generated_data_graph').clear()
            
            if(num_dimensions == 2):
                plt.scatter('Dimension 1', 'Dimension 2', c='Cluster', data=df)
                plt.xlabel('Dimension 1')
                plt.ylabel('Dimension 2')
                plt.title('Plot of Generated Data')
                display(plt, target="generated_data_graph")
                plt.clf()
            
            if(num_dimensions == 3):
                ax = plt.axes(projection ="3d")
                ax.scatter3D('Dimension 1', 'Dimension 2', 'Dimension 3', c='Cluster', data=df)
                ax.set_xlabel('Dimension 1')
                ax.set_ylabel('Dimension 2')
                ax.set_zlabel('Dimension 3')
                plt.title('Plot of Generated Data')
                display(plt, target="generated_data_graph")
                plt.clf()
        

            # display description on page
            data_description_div = Element("data_description")
            data_description_div.element.innerHTML = df.groupby('Cluster').describe().T.to_html()    
        
        def download_data():
            df.to_csv("cluster_data.csv")     




        # Clustering Code

        from sklearn.cluster import KMeans, AgglomerativeClustering
        from sklearn.mixture import GaussianMixture
        from sklearn.cluster import MeanShift
        from sklearn.metrics import precision_score, recall_score, f1_score, adjusted_rand_score
        from sklearn.metrics import silhouette_score
        from sklearn.metrics import davies_bouldin_score

        num_clusters = js.no_of_cluster_algo
        
        def perform_kmeans(df):
            num_clusters = js.no_of_cluster_algo
            kmeans = KMeans(n_clusters=num_clusters)
            labels = kmeans.fit_predict(df)
            return labels, "K-Means"
            
        def perform_hierarchical_clustering(df):
            num_clusters = js.no_of_cluster_algo
            hierarchical = AgglomerativeClustering(n_clusters=num_clusters)
            labels = hierarchical.fit_predict(df)
            return labels, "Hierarchical Clustering"
            
        def perform_gmm(df):
            num_clusters = js.no_of_cluster_algo
            gmm = GaussianMixture(n_components=num_clusters)
            labels = gmm.fit_predict(df)
            return labels, "Gaussian Mixture Model"
            
        def perform_mean_shift(df):
            num_clusters = js.no_of_cluster_algo
            meanshift = MeanShift()
            labels = meanshift.fit_predict(df)
            return labels, "Mean Shift"
        
        algorithms = {
            "kmeans": perform_kmeans,
            "hierarchical_clustering": perform_hierarchical_clustering,
            "gmm": perform_gmm,
            "mean_shift": perform_mean_shift
        }
        
        algorithm_name = ""

        def clustering(choice):
            num_clusters = js.no_of_cluster_algo
            num_dimensions = js.no_of_dimensions
            no_of_gen_cluster = js.no_of_cluster

            df_algo = df.drop(columns=['Cluster'])
            labels, algorithm_name = algorithms[choice](df_algo)
        
            # Calculate and display external measures
            true_labels = df['Cluster']
            if(no_of_gen_cluster == 2):
                true_labels_map = {'C1': 0, 'C2': 1}
            if(no_of_gen_cluster == 3):
                true_labels_map = {'C1': 0, 'C2': 1, 'C3': 2}
            true_labels_int = true_labels.map(true_labels_map)
        
            precision = precision_score(true_labels_int, labels, average='weighted')
            Element("precision").element.innerHTML = precision
            
            recall = recall_score(true_labels_int, labels, average='weighted')
            Element("recall").element.innerHTML = recall
            
            f_measure = f1_score(true_labels_int, labels, average='weighted')
            Element("f_measure").element.innerHTML = f_measure
            
            ari = adjusted_rand_score(true_labels_int, labels)
            Element("ari").element.innerHTML = ari
            
            # Calculate and display internal measures
            kmeans = KMeans(n_clusters=num_clusters)
            kmeans.fit(df_algo)
            sse = kmeans.inertia_
            Element("sse").element.innerHTML = sse
            
            silhouette = silhouette_score(df_algo, labels)
            Element("silhouette").element.innerHTML = silhouette
            
            dunn = davies_bouldin_score(df_algo, labels)
            Element("dunn").element.innerHTML = dunn

            # add clustering algo label on df_algo
            add_C = lambda x: [f"C{c}" for c in x]
            df_algo[f"{algorithm_name} Cluster"] = add_C(labels+1)


            # Plot the Clustered Data
            Element('cluster_data_graph').clear()

            if(num_dimensions == 2):
                plt.scatter('Dimension 1', 'Dimension 2', c=f"{algorithm_name} Cluster", data=df_algo)
                plt.xlabel('Dimension 1')
                plt.ylabel('Dimension 2')
                plt.title(f'Clusters Formed by {algorithm_name}')
                display(plt, target="cluster_data_graph")
                plt.clf()

            if(num_dimensions == 3):
                ax = plt.axes(projection ="3d")
                ax.scatter3D('Dimension 1', 'Dimension 2', 'Dimension 3', c=f"{algorithm_name} Cluster", data=df_algo)
                ax.set_xlabel('Dimension 1')
                ax.set_ylabel('Dimension 2')
                ax.set_zlabel('Dimension 3')
                plt.title(f'Clusters Formed by {algorithm_name}')
                display(plt, target="cluster_data_graph")
                plt.clf()

            # display cluster description on page
            cluster_description_div = Element("cluster_description")
            cluster_description_div.element.innerHTML = df_algo.groupby(f"{algorithm_name} Cluster").describe().T.to_html()

    </py-script>

  </body>
</html>